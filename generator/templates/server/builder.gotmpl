package {{.Package}}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "strings"
  "net/http"
  "github.com/casualjim/go-swagger"
  "github.com/casualjim/go-swagger/spec"
  "github.com/casualjim/go-swagger/security"
  "github.com/casualjim/go-swagger/middleware"

  {{range .Imports}}
  {{ printf "%q" .}}
  {{end}}
)

// {{.AppName}}API {{.Info.Description}}
type {{.AppName}}API struct {
  spec           *spec.Document
  context        *middleware.Context
  handlers       map[string]http.Handler
  {{range .Consumes}}// {{.ClassName}}Consumer registers a consumer for a "{{.MediaType}}" mime type
  {{.ClassName}}Consumer swagger.Consumer
  {{end}}
  {{range .Produces}}// {{.ClassName}}Producer registers a producer for a "{{.MediaType}}" mime type
  {{.ClassName}}Producer swagger.Producer
  {{end}}
  {{range .SecurityDefinitions}}
  {{if .IsBasicAuth}}// {{.ClassName}}Auth registers a function that takes username and password and returns a principal
  // it performs authentication with basic auth
  {{.ClassName}}Auth func(string, string) ({{.Principal}}, error)
  {{end}}{{if .IsAPIKeyAuth}}// {{.ClassName}}Auth registers a function that takes a token and returns a principal
  // it performs authentication based on an api key {{.ParamName}} provided in the {{.Source}}
  {{.ClassName}}Auth func(string) ({{.Principal}}, error)
  {{end}}
  {{end}}
  {{range .Operations}}// {{.ClassName}}Handler sets the operation handler for the {{.HumanClassName}} operation
  {{if .Package}}{{.ClassName}}Handler {{.Package}}.{{.ClassName}}Handler
  {{else}}{{.ClassName}}Handler {{.ClassName}}Handler
  {{end}}
  {{end}}
  // ServeError is called when an error is received, there is a default handler
  // but you can set your own with this
  ServeError     func(http.ResponseWriter, *http.Request, error)
}

// Validate validates the registrations in the {{.AppName}}API
func ({{.ReceiverName}} *{{.AppName}}API) Validate() error {
  var unregistered []string
  {{range .Consumes}}
  if {{.ReceiverName}}.{{.ClassName}}Consumer == nil {
    unregistered = append(unregistered, "{{.ClassName}}Consumer")
  }
  {{end}}
  {{range .Produces}}
  if {{.ReceiverName}}.{{.ClassName}}Producer == nil {
    unregistered = append(unregistered, "{{.ClassName}}Producer")
  }
  {{end}}
  {{range .SecurityDefinitions}}
  if {{.ReceiverName}}.{{.ClassName}}Auth == nil {
    unregistered = append(unregistered, "{{.ClassName}}Auth")
  }
  {{end}}
  {{range .Operations}}
  if {{.ReceiverName}}.{{.ClassName}}Handler == nil {
    unregistered = append(unregistered, "{{.ClassName}}Handler")
  }
  {{end}}

  sz := len(unregistered)
  if sz == 0 {
    return nil
  }

  return fmt.Errorf("missing registration: %s", strings.Join(unregistered, ", "))
}
// ServeErrorFor gets a error handler for a given operation id
func ({{.ReceiverName}} *{{.AppName}}API) ServeErrorFor(operationID string) func(http.ResponseWriter, *http.Request, error) {
  return {{.ReceiverName}}.ServeError
}
// AuthenticatorsFor gets the authenticators for the specified security schemes
func ({{.ReceiverName}} *{{.AppName}}API) AuthenticatorsFor(schemes map[string]spec.SecurityScheme) map[string]swagger.Authenticator {
  {{if .SecurityDefinitions}}
  result := make(map[string]swagger.Authenticator)
  for name, scheme := range schemes {
    switch name {
      {{range .SecurityDefinitions}}
      case "{{.Name}}":
        {{if .IsBasicAuth}}result[name] = security.BasicAuth({{.ReceiverName}}.{{.ClassName}}Auth){{end}}
        {{if .IsAPIKeyAuth}}result[name] = security.APIKeyAuth(scheme.Name, scheme.In, {{.ReceiverName}}.{{.ClassName}}Auth){{end}}
      {{end}}
    }
  }
  return result
  {{else}}
  return nil
  {{end}}
}

// ConsumersFor gets the consumers for the specified media types
func ({{.ReceiverName}} *{{.AppName}}API) ConsumersFor(mediaTypes []string) map[string]swagger.Consumer {
  {{if .Consumes}}
  result := make(map[string]swagger.Consumer)
  for _, mt := range mediaTypes {
    switch mt {
      {{range .Consumes}}
      {{range .AllSerializers}}
      case "{{.MediaType}}":
        result["{{.MediaType}}"] = {{.ReceiverName}}.{{.ClassName}}Consumer
      {{end}}
      {{end}}
    }
  }
  return result
  {{else}}
  return nil
  {{end}}
}

// ProducersFor gets the producers for the specified media types
func ({{.ReceiverName}} *{{.AppName}}API) ProducersFor(mediaTypes []string) map[string]swagger.Producer {
  {{if.Produces}}
  result := make(map[string]swagger.Producer)
  for _, mt := range mediaTypes {
    switch mt {
      {{range .Produces}}
      {{range .AllSerializers}}
      case "{{.MediaType}}":
        result["{{.MediaType}}"] = {{.ReceiverName}}.{{.ClassName}}Producer
      {{end}}
      {{end}}
    }
  }
  return result
  {{else}}
  return nil
  {{end}}
}

// HandlerFor gets a http.Handler for the provided operation id
func ({{.ReceiverName}} *{{.AppName}}API) HandlerFor(operationID string) (http.Handler, bool) {
  if len({{.ReceiverName}}.handlers) == 0 {
    {{.ReceiverName}}.initHandlerCache()
  }
  if {{.ReceiverName}}.handlers == nil {
    return nil, false
  }
  h, ok := {{.ReceiverName}}.handlers[operationID]
  return h, ok
}

func ({{.ReceiverName}} *{{.AppName}}API) initHandlerCache() {
  if {{.ReceiverName}}.context == nil {
    {{.ReceiverName}}.context = middleware.NewRoutableContext({{.ReceiverName}}.spec, {{.ReceiverName}}, nil)
  }
  {{if .Operations}}
  {{.ReceiverName}}.handlers = make(map[string]http.Handler)
  {{range .Operations}}
  {{if .Package}}
  {{.ReceiverName}}.handlers["{{.Name}}"] = {{.Package}}.New{{.ClassName}}({{.ReceiverName}}.context, {{.ReceiverName}}.{{.ClassName}}Handler)
  {{else}}
  {{.ReceiverName}}.handlers["{{.Name}}"] = New{{.ClassName}}({{.ReceiverName}}.context, {{.ReceiverName}}.{{.ClassName}}Handler)
  {{end}}
  {{end}}
  {{end}}
}
