package {{.Package}}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the generate command

import (
  "net/http"

  {{range .DefaultImports}}{{printf "%q" .}}
  {{end}}
  {{range $key, $value := .Imports}}{{$key}} {{ printf "%q" $value}}
  {{end}}
)

// {{.ClassName}}HandlerFunc turns a function with the right signature into a {{.HumanClassName}} handler
type {{.ClassName}}HandlerFunc func({{if .Params}}{{.ClassName}}Params{{end}}{{if and .Authorized .Params}}, {{end}}{{if .Authorized}}*{{.Principal}}{{end}}) ({{if .SuccessModel}}{{if .ReturnsComplexObject}}*{{end}}{{.SuccessModel}}, {{end}}error)

func (fn {{.ClassName}}HandlerFunc) Handle({{if .Params}}params {{.ClassName}}Params{{end}}{{if and .Authorized .Params}}, {{end}}{{if .Authorized}}principal *{{.Principal}}{{end}}) ({{if .SuccessModel}}{{if .ReturnsComplexObject}}*{{end}}{{.SuccessModel}}, {{end}}error) {
  return fn({{if .Params}}params{{end}}{{if and .Authorized .Params}}, {{end}}{{if .Authorized}}principal{{end}})
}

// {{.ClassName}}Handler interface for that can handle valid {{.HumanClassName}} params
type {{.ClassName}}Handler interface {
  Handle({{if .Params}}{{.ClassName}}Params{{end}}{{if and .Authorized .Params}}, {{end}}{{if .Authorized}}*{{.Principal}}{{end}}) ({{if .SuccessModel}}{{if .ReturnsComplexObject}}*{{end}}{{.SuccessModel}}, {{end}}error)
}

// New{{.ClassName}} creates a new http.Handler for the {{.HumanClassName}} operation
func New{{.ClassName}}(ctx *middleware.Context, handler {{.ClassName}}Handler) *{{.ClassName}} {
  return &{{.ClassName}}{Context: ctx, Handler: handler}
}

{{if .DocString}}{{.DocString}}{{end}}
type {{.ClassName}} struct {
  Context *middleware.Context
  {{if .Params}}Params  {{.ClassName}}Params
  {{end}}Handler {{.ClassName}}Handler
}

func ({{.ReceiverName}} *{{.ClassName}}) ServeHTTP(rw http.ResponseWriter, r *http.Request) {
  route, _ := {{.ReceiverName}}.Context.RouteInfo(r)

  {{if .Authorized}}uprinc, err := {{.ReceiverName}}.Context.Authorize(r, route)
  if err != nil {
    {{.ReceiverName}}.Context.Respond(rw, r, route.Produces, route, err)
    return
  }
  var principal {{if not (eq .Principal "interface{}")}}*{{end}}{{.Principal}}
  if uprinc != nil {
    principal = {{if eq .Principal "interface{}"}}uprinc{{else}}uprinc.(*{{.Principal}}) // it's ok this is really a {{.Principal}}{{end}}
  }

  {{end}}
  if err := {{.ReceiverName}}.Context.BindValidRequest(r, route, {{if .Params}}&{{.ReceiverName}}.Params{{else}}nil{{end}}); err != nil { // bind params
    {{.ReceiverName}}.Context.Respond(rw, r, route.Produces, route, err)
    return
  }

  {{if .Authorized}}
  {{if .SuccessModel}}res, {{end}}err {{if .SuccessModel}}:{{end}}= {{.ReceiverName}}.Handler.Handle({{if .Params}}{{.ReceiverName}}.Params, {{end}}principal) // actually handle the request
  if err != nil {
    {{.ReceiverName}}.Context.Respond(rw, r, route.Produces, route, err)
    return
  }

  {{.ReceiverName}}.Context.Respond(rw, r, route.Produces, route, {{if .SuccessModel}}res{{else}}nil{{end}})
  {{else}}
  {{if .SuccessModel}}res, {{end}}err := {{.ReceiverName}}.Handler.Handle({{if .Params}}{{.ReceiverName}}.Params{{end}}) // actually handle the request
  if err != nil {
    {{.ReceiverName}}.Context.Respond(rw, r, route.Produces, route, err)
    return
  }
  {{.ReceiverName}}.Context.Respond(rw, r, route.Produces, route, {{if .SuccessModel}}res{{else}}nil{{end}})
  {{end}}
}
