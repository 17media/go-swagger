{{define "primitivevalidator"}}
{{if .MinLength}}
if err := validate.MinLength({{.Path}}, "{{.Location}}", {{.ValueExpression}}, {{.MinLength}}); err != nil {
  return err
}
{{end}}
{{if .MaxLength}}
if err := validate.MaxLength({{.Path}}, "{{.Location}}", {{.ValueExpression}}, {{.MaxLength}}); err != nil {
  return err
}
{{end}}
{{if .Pattern}}
if err := validate.Pattern({{.Path}}, "{{.Location}}", {{.ValueExpression}}, `{{.Pattern}}`); err != nil {
  return err
}
{{end}}
{{if .Minimum}}
if err := validate.Minimum({{.Path}}, "{{.Location}}", float64({{.ValueExpression}}), {{.Minimum}}, {{.ExclusiveMinimum}}); err != nil {
  return err
}
{{end}}
{{if .Maximum}}
if err := validate.Maximum({{.Path}}, "{{.Location}}", float64({{.ValueExpression}}), {{.Maximum}}, {{.ExclusiveMaximum}}); err != nil {
  return err
}
{{end}}
{{if .MultipleOf}}
if err := validate.MultipleOf({{.Path}}, "{{.Location}}", float64({{.ValueExpression}}), {{.MultipleOf}}); err != nil {
  return err
}
{{end}}
{{if .Enum}}
if err := validate.Enum({{.Path}}, "{{.Location}}", {{.ValueExpression}}, {{.Enum}}); err != nil {
  return err
}
{{end}}
{{end}}{{define "customformatvalidator"}}
if err := validate.FormatOf({{.Path}}, "{{.Location}}", "{{.Format}}", string({{.ValueExpression}})); err != nil {
  return err
}
{{end}}{{define "slicevalidator"}}
{{if .NeedsSize}}
{{.ParamName}}Size := int64(len({{.ValueExpression}}))
{{end}}
{{if .MinItems}}
if err := validate.MinItems({{.Path}}, "{{.Location}}", {{.ParamName}}Size, {{.MinItems}}); err != nil {
  return err
}
{{end}}
{{if .MaxItems}}
if err := validate.MaxItems({{.Path}}, "{{.Location}}", {{.ParamName}}Size, {{.MaxItems}}); err != nil {
  return err
}
{{end}}
{{if .UniqueItems}}
if err := validate.UniqueItems({{.Path}}, "{{.Location}}", {{.ValueExpression}}); err != nil {
  return err
}
{{end}}
{{if .Enum}}
if err := validate.Enum({{.Path}}, "{{.Location}}", {{.ValueExpression}}, {{.Enum}}); err != nil {
  return err
}
{{end}}
{{end}}{{define "propertyvalidator"}}
{{if .IsPrimitive}}{{template "primitivevalidator" .}}{{end}}
{{if .IsCustomFormatter}}{{template "customformatvalidator" .}}{{end}}
{{if .IsContainer}}{{template "slicevalidator" .}}{{end}}
{{end}}{{define "bindprimitive"}}
{{end}}{{define "slicebinder"}}
{{if .Parent}}{{.IndexVar}}c := util.SplitByFormat({{.Parent.IndexVar}}c[{{.Parent.IndexVar}}], "{{.CollectionFormat}}")
{{else}}{{.IndexVar}}c := raw{{end}}
{{.IndexVar}}sz := size
var {{.IndexVar}}r {{.Type}}
{{.IndexVar}}ValidateElement := func({{.IndexVar}} int, {{.Child.ValueExpression}} {{.Child.Type}}) *errors.Validation {
  {{template "propertyvalidator" .Child}}
  return nil
}

for {{.IndexVar}} := 0; {{.IndexVar}} < {{.IndexVar}}sz; {{.IndexVar}}++ {
  {{if .Child.IsPrimitive}}{{if .Child.Converter}}value, err := {{.Child.Converter}}({{.IndexVar}}c[{{.IndexVar}}])
  if err != nil {
    res.AddErrors(errors.InvalidType({{.Child.Path}}, "{{.Location}}", "{{.Child.Type}}", {{.IndexVar}}c[{{.IndexVar}}]))
    return res
  }

  if err := {{.IndexVar}}ValidateElement({{.IndexVar}}, {{.Child.ValueExpression}}); err != nil {
    res.AddErrors(err)
    return res
  }
  res.Inc()
  {{.IndexVar}}r = append({{.IndexVar}}r, value)
  {{else}}
    if err := {{.IndexVar}}ValidateElement({{.IndexVar}}, {{.IndexVar}}c[{{.IndexVar}}]); err != nil {
      res.AddErrors(err)
      return res
    }

    res.Inc()
  {{.IndexVar}}r = append({{.IndexVar}}r, {{.IndexVar}}c[{{.IndexVar}}]){{end}}{{else if .Child.IsContainer}}
  {{template "slicebinder" .Child}}
    if err := {{.IndexVar}}ValidateElement({{.IndexVar}}, {{.Child.IndexVar}}r); err != nil {
      res.AddErrors(err)
      return res
    }
    res.Inc()
  {{.IndexVar}}r = append({{.IndexVar}}r, {{.Child.IndexVar}}r){{end}}
}
{{end}}package {{.Package}}

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
  "net/http"
  "github.com/casualjim/go-swagger"
  "github.com/casualjim/go-swagger/errors"
  "github.com/casualjim/go-swagger/httputils"
  "github.com/casualjim/go-swagger/router"
  "github.com/casualjim/go-swagger/validate"

  {{range .Imports}}
  {{ printf "%q" .}}
  {{end}}
)

// {{.ClassName}}Params contains all the bound params for the {{.HumanClassName}} operation
// typically these are obtained from a http.Request
type {{.ClassName}}Params struct {
  {{range .Params}}{{if .Description}}// {{.Description}}{{end}}
  {{.PropertyName}} {{.Type}}
  {{end}}
}

// BindRequest both binds and validates a request, it assumes that complex things implement a Validatable() *validate.Result interface
// for simple values it will use straight method calls
func ({{.ReceiverName}} *{{.ClassName}}Params) BindRequest(r *http.Request, route *router.MatchedRoute, consumer swagger.Consumer) *validate.Result {
  res := new(validate.Result)
  {{if .HasQueryParams}}qs := r.URL.Query()
  {{end}}

  {{range .Params}}
  {{if .IsPrimitive}}{{if .IsQueryParam}}res.Merge({{.ReceiverName}}.bind{{.PropertyName}}(httputils.ReadSingleValue(qs, {{.Path}})))
  {{else if .IsPathParam}}res.Merge({{.ReceiverName}}.bind{{.PropertyName}}(httputils.ReadSingleValue(route.Params, {{.Path}})))
  {{else if .IsHeaderParam}}res.Merge({{.ReceiverName}}.bind{{.PropertyName}}(httputils.ReadSingleValue(r.Header, {{.Path}})))
  {{end}}
  {{else if .IsContainer}}{{if .IsQueryParam}}res.Merge({{.ReceiverName}}.bind{{.PropertyName}}(httputils.ReadCollectionValue(qs, {{.Path}}, "{{.CollectionFormat}}")))
  {{else if .IsPathParam}}res.Merge({{.ReceiverName}}.bind{{.PropertyName}}(httputils.ReadCollectionValue(route.Params, {{.Path}}, "{{.CollectionFormat}}")))
  {{else if .IsHeaderParam}}res.Merge({{.ReceiverName}}.bind{{.PropertyName}}(httputils.ReadCollectionValue(r.Header, {{.Path}}, "{{.CollectionFormat}}")))
  {{end}}{{end}}

  {{if .IsBodyParam}}
  if err := consumer.Consume(r.Body, &{{.ReceiverName}}.{{.PropertyName}}); err != nil {
    res.AddErrors(errors.NewParseError("{{.ParamName}}", "{{.Location}}", "", err))
  } else {
    res.Merge({{.ReceiverName}}.{{.PropertyName}}.Validate())
  }
  {{end}}
  {{end}}

  return res
}

{{ $className := .ClassName }}
{{range .Params}}
{{if or .IsPrimitive .IsCustomFormatter}}
func ({{.ReceiverName}} *{{$className}}Params) bind{{.PropertyName}}(raw string) *validate.Result {
  res := new(validate.Result)

  {{if .Required}}if err := validate.RequiredString({{.Path}}, "{{.Location}}", raw); err != nil {
    res.AddErrors(err)
    return res
  }
  res.Inc()
  {{end}}
  {{if .Converter}}value, err := {{.Converter}}(raw)
  if err != nil {
    res.AddErrors(errors.InvalidType({{.Path}}, "{{.Location}}", "{{.Type}}", raw))
    return res
  }
  res.Inc()
  {{.ValueExpression}} = value
  {{else}}
  {{.ValueExpression}} = raw
  {{end}}
  {{if .HasValidations}}if err := {{.ReceiverName}}.validate{{.PropertyName}}(); err != nil {
    res.AddErrors(err)
  }

  if res.IsValid() {
    res.Inc()
  }
  {{end}}
  return res
}
{{else if .IsContainer}}
func ({{.ReceiverName}} *{{$className}}Params) bind{{.PropertyName}}(raw []string) *validate.Result {
  res := new(validate.Result)
  size := len(raw)

  {{if .Required}}if size == 0 {
    res.AddErrors(errors.Required({{.Path}}, "{{.Location}}"))
    return res
  }
  res.Inc()
  {{end}}

  {{if .DefaultValue}}if size == 0 && len({{.DefaultValue}}) > 0 {
    {{.ValueExpression}} = {{.DefaultValue}}
  {{else}}if size == 0 {
    res.Inc()
    return res{{end}}
  }
  {{template "slicebinder" .}}{{.ValueExpression}} = {{.IndexVar}}r
  {{if .HasSliceValidations}}if err := {{.ReceiverName}}.validate{{.PropertyName}}(); err != nil {
    res.AddErrors(err)
  }

  if res.IsValid() {
    res.Inc()
  }
  {{end}}
  return res
}
{{end}}
{{if or .HasValidations .HasSliceValidations}}
func ({{.ReceiverName}} *{{$className}}Params) validate{{.PropertyName}}() *errors.Validation {
  {{template "propertyvalidator" .}}

  return nil
}
{{end}}
{{end}}
